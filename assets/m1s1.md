# Submódulo 1 Diseña algoritmos de problemas de seguridad

## Elabora algoritmos para la solución de problemas de seguridad informática

### Analiza un problema de seguridad informática, considerando los pasos a seguir para el análisis de información, utilizando las tecnologías de información y comunicación empleando el pensamiento lógico-matemático, trabajando de forma autónoma o colaborativa y cumpliendo con las instrucciones de su jefe inmediato.

**Objetivo:** Seguir un proceso lógico‑matemático para analizar información de un incidente o riesgo, aprovechando TIC, y trabajando de forma autónoma o colaborativa bajo la supervisión de un jefe inmediato.

```pseudocode
Algoritmo Analizar_Problema_Seguridad()
    // 1. Recepción de la orden
    Recibir_instrucciones(jefe_inmediato)  
    // 2. Definir alcance y objetivos
    Definir_objetivos(proyecto, alcance)  
    // 3. Recolección de información
    //    - Logs de sistemas
    //    - Entrevistas con usuarios
    //    - Reportes de monitoreo
    datos ← Obtener_logs()
    entrevistas ← Realizar_entrevistas(equipo, usuarios)
    reportes ← Descargar_reportes(monitoreo_TIC)
    // 4. Clasificación y pre‑procesamiento
    activos ← Identificar_activos(datos, entrevistas)
    datos_limpios ← Filtrar_ruido(datos)
    // 5. Análisis de vulnerabilidades y amenazas
    Para cada activo en activos:
        riesgos_activo ← Evaluar_amenazas(activo)
        vulnerabilidades ← Escanear_vulnerabilidades(activo)  
        matriz_riesgos[activo] ← Calcular_riesgo(riesgos_activo, vulnerabilidades)
    FinPara
    // 6. Colaboración y validación
    Si modo_colaborativo Entonces
        Compartir_resultados(equipo)
        Reunión_discusión(equipo)
    FinSi
    // 7. Elaboración del informe
    informe ← Generar_informe(matriz_riesgos, hallazgos, recomendaciones)
    // 8. Revisión y retroalimentación
    Enviar_a_revisión(jefe_inmediato, informe)
    feedback ← Recibir_feedback(jefe_inmediato)
    Ajustar_informe(informe, feedback)
    // 9. Entrega final
    Entregar_informe(informe, jefe_inmediato)
FinAlgoritmo
```

**Comentarios clave:**

* Uso de **TIC**: obtención automática de logs, herramientas de escaneo de vulnerabilidades, sistemas de gestión de incidentes.
* **Pensamiento lógico‑matemático**: clasificación de activos, cálculo de matrices de riesgo.
* **Trabajo autónomo o colaborativo**: permite adaptarse a ambos modos según instrucciones.
* **Instrucciones del jefe inmediato**: recepción, revisión y aprobación del informe final.

---

### Diseña el algoritmo considerando el análisis del problema de seguridad informática, utilizando los diagramas de flujo de datos y estructuras de control; utilizando las tecnologías de información y comunicación, empleando el pensamiento lógico-matemático y trabajando de forma autónoma o colaborativa.

**Objetivo:** Incluir explícitamente la construcción/uso de DFD y estructuras de control (condicionales, bucles) para modelar el proceso de análisis.

```pseudocode
Algoritmo Analizar_Con_DFD()
    // 1. Definir contexto del DFD
    contexto ← Crear_DFD_Contexto(sistema_objetivo)
    Nivel1 ← Descomponer_DFD(contexto)
    // 2. Inicializar estructuras de control y variables
    riesgos_detectados ← []
    i ← 0
    // 3. Recorrer cada flujo de datos del DFD de Nivel 1
    Mientras i < Longitud(Nivel1.flujos)
        flujo ← Nivel1.flujos[i]
        // 3.1 Validar confidencialidad
        Si flujo.es_confidencial Entonces
            Si No validar_cifrado(flujo) Entonces
                riesgos_detectados.Agregar({flujo, "Sin cifrado"})
            FinSi
        FinSi
        // 3.2 Validar integridad
        Si flujo.requiere_integridad Entonces
            datos_muestra ← Capturar_muestra(flujo)
            Si No comprobar_hash(datos_muestra) Entonces
                riesgos_detectados.Agregar({flujo, "Hash inválido"})
            FinSi
        FinSi
        // 3.3 Validar disponibilidad / latencia
        latencia ← Medir_latencia(flujo)
        Si latencia > flujo.umbral_entrega Entonces
            riesgos_detectados.Agregar({flujo, "Alta latencia"})
        FinSi
        i ← i + 1
    FinMientras
    // 4. Validar controles de acceso en cada proceso
    Para cada proceso en Nivel1.procesos
        controles ← Obtener_controles_acceso(proceso)
        Si controles.ninguno Entonces
            riesgos_detectados.Agregar({proceso, "Sin control de acceso"})
        FinSi
    FinPara
    // 5. Diagramar los hallazgos en un DFD de riesgos
    DFD_riesgos ← Crear_DFD_Con_Riesgos(Nivel1, riesgos_detectados)
    // 6. Colaboración y mejora
    Si modo_colaborativo Entonces
        Revisar_DFD(equipo, DFD_riesgos)
        Incorporar_sugerencias(DFD_riesgos)
    FinSi
    // 7. Generar plan de mitigación
    Para cada elemento en riesgos_detectados
        plan_mitigación[elemento] ← Proponer_mitigation(matriz_riesgos[elemento])
    FinPara
    // 8. Entrega de resultados
    Presentar_DFD(Dfd_riesgos, plan_mitigación, jefe_inmediato)
FinAlgoritmo
```

**Comentarios clave:**

* **Diagramas de Flujo de Datos (DFD):** se crean contexto, nivel 1 y luego un DFD de riesgos.
* **Estructuras de control:** `Mientras`, `Para cada`, `Si…Entonces` para modelar iteraciones y decisiones.
* Incorpora **TIC** para mediciones automáticas (latencia, hash), escaneo de cifrado y controles de acceso.
* Facilita **pensamiento lógico‑matemático** en la evaluación cuantitativa de latencia y validación de integridad.
* Permite **trabajo autónomo o colaborativo**, con ciclos de revisión iterativos.

---
Referencias 

> Joint Task Force Transformation Initiative. (2012). *Guide for Conducting Risk Assessments* (NIST Special Publication 800‑30 Rev. 1). National Institute of Standards and Technology.

> Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). *Introduction to Algorithms* (3.ª ed.). MIT Press.


______________________________

import json


def analizar_problema_seguridad(jefe_inmediato, datos_logs, entrevistas, reportes_monitoreo, modo_colaborativo=False):
    """
    Analiza un problema de seguridad informática siguiendo estos pasos:
      1. Recepción de instrucciones y definición de objetivos
      2. Recolección y preprocesamiento de información
      3. Evaluación de vulnerabilidades y cálculo de matriz de riesgos
      4. Colaboración y validación de hallazgos
      5. Generación y entrega de informe final
    Parámetros:
      jefe_inmediato: objeto con método get_instrucciones()
      datos_logs: ruta o estructura de logs de sistemas
      entrevistas: lista de participantes para entrevistas
      reportes_monitoreo: origen de datos de monitoreo automático
      modo_colaborativo: booleano para compartir resultados intermedios
    Retorna:
      informe final como diccionario
    """
    # 1. Recepción de instrucciones y definición de objetivos
    instrucciones = jefe_inmediato.get_instrucciones()
    proyecto = instrucciones.get('proyecto')
    alcance = instrucciones.get('alcance')
    objetivos = {
        'proyecto': proyecto,
        'alcance': alcance
    }

    # 2. Recolección y preprocesamiento
    datos = obtener_logs(datos_logs)
    entrevistas_data = realizar_entrevistas(entrevistas)
    reportes = descargar_reportes(reportes_monitoreo)

    activos = identificar_activos(datos, entrevistas_data)
    datos_limpios = filtrar_ruido(datos)

    # 3. Evaluación de vulnerabilidades y cálculo de matriz_ riesgos
    matriz_riesgos = {}
    for activo in activos:
        amenazas = evaluar_amenazas(activo)
        vulnerabilidades = escanear_vulnerabilidades(activo)
        riesgo = calcular_riesgo(amenazas, vulnerabilidades)
        matriz_riesgos[activo] = riesgo

    # 4. Colaboración y validación
    if modo_colaborativo:
        compartir_resultados(equipo=get_equipo(), resultados=matriz_riesgos)
        realizar_reunion(equipo=get_equipo())

    # 5. Generación y entrega de informe
    informe = generar_informe(matriz_riesgos, hallazgos=amenazas, recomendaciones=vulnerabilidades)
    feedback = jefe_inmediato.revisar(informe)
    informe_final = ajustar_informe(informe, feedback)
    jefe_inmediato.entregar(informe_final)
    return informe_final


def analizar_con_dfd(sistema_objetivo, modo_colaborativo=False):
    """
    Utiliza Diagramas de Flujo de Datos (DFD) y estructuras de control para analizar riesgos:
      1. Construcción de DFD Contexto y Nivel 1
      2. Validación de confidencialidad, integridad y disponibilidad
      3. Detección de fallas en controles de acceso
      4. Generación de DFD de riesgos y plan de mitigación
      5. Entrega de resultados
    Parámetros:
      sistema_objetivo: descriptor o identificador del sistema a modelar
      modo_colaborativo: booleano para revisar con equipo
    Retorna:
      estructura con DFD de riesgos y plan de mitigación
    """
    # 1. Construir DFD
    contexto = crear_dfd_contexto(sistema_objetivo)
    nivel1 = descomponer_dfd(contexto)

    riesgos_detectados = []

    # 2. Recorrer flujos de Nivel1 con estructuras de control
    for flujo in nivel1['flujos']:
        # Confidencialidad
        if flujo.get('es_confidencial') and not validar_cifrado(flujo):
            riesgos_detectados.append((flujo['id'], 'Sin cifrado'))
        # Integridad
        if flujo.get('requiere_integridad'):
            muestra = capturar_muestra(flujo)
            if not comprobar_hash(muestra):
                riesgos_detectados.append((flujo['id'], 'Hash inválido'))
        # Disponibilidad
        latencia = medir_latencia(flujo)
        if latencia > flujo.get('umbral_entrega'):
            riesgos_detectados.append((flujo['id'], 'Alta latencia'))

    # 3. Validar controles de acceso
    for proceso in nivel1['procesos']:
        controles = obtener_controles_acceso(proceso)
        if not controles:
            riesgos_detectados.append((proceso['id'], 'Sin control de acceso'))

    # 4. Generar DFD de riesgos y plan de mitigación
    dfd_riesgos = crear_dfd_con_riesgos(nivel1, riesgos_detectados)
    plan_mitigacion = {}
    for elemento, motivo in riesgos_detectados:
        plan_mitigacion[elemento] = proponer_mitigacion(motivo)

    # 5. Revisión colaborativa y entrega
    if modo_colaborativo:
        revisar_con_equipo(dfd_riesgos)
        incorporar_sugerencias(dfd_riesgos)

    return {
        'dfd_riesgos': dfd_riesgos,
        'plan_mitigacion': plan_mitigacion
    }
