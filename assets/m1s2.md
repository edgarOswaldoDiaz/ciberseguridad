# Submódulo 2 implementa scripts en un lenguaje de programación para la solución de problemas de seguridad

## Identificar scripts existentes, elaborados por terceros o de repositorios en la red, que atienden problemas cotidianos en las empresas y que son susceptibles de ser adaptados para reducir el tiempo de atención.

A continuación se presentan cinco scripts de terceros, obtenidos de repositorios públicos, que resuelven problemáticas comunes en empresas y pueden adaptarse para optimizar tiempos de respuesta:

**Automatización de escaneo de vulnerabilidades con Nmap**

   * **Descripción:** Script en Bash que lanza escaneos regulares de puertos y servicios con Nmap, genera reportes en PDF y envía alertas por correo.
   * **Repositorio:** [https://github.com/honze-net/nmapAutomator](https://github.com/honze-net/nmapAutomator)
   * **Adaptación:** Integrar en un pipeline de CI/CD, permitir escaneos diferenciales y exportar resultados a un dashboard centralizado.

**Rotación y compresión de logs**

   * **Descripción:** Script en Python que aplica rotación de archivos de log según tamaño o antigüedad, los comprime en formato `.gz` y los archiva en un servidor remoto.
   * **Repositorio:** [https://github.com/alexbelgium/homelab-scripts/blob/master/logrotate.py](https://github.com/alexbelgium/homelab-scripts/blob/master/logrotate.py)
   * **Adaptación:** Añadir control por configuración YAML, notificaciones a Slack y limpieza automática de archivos antiguos.

**Verificación de integridad de archivos (hashing)**

   * **Descripción:** Script en PowerShell que calcula y compara hashes SHA-256 de archivos críticos, alertando si hay discrepancias.
   * **Repositorio:** [https://gallery.technet.microsoft.com/scriptcenter/Get-FileHash-a6afa11e](https://gallery.technet.microsoft.com/scriptcenter/Get-FileHash-a6afa11e)
   * **Adaptación:** Programar ejecuciones periódicas en Task Scheduler, exportar resultados a una base de datos SQL y generar reportes en HTML.

**Monitoreo de servicios en Linux (systemd)**

   * **Descripción:** Script en Python que consulta el estado de servicios bajo systemd, reinicia automáticamente si detecta caídas y registra eventos en syslog.

   * **Repositorio:** [https://github.com/onecocasunco/systemd-watchdog](https://github.com/onecocasunco/systemd-watchdog)

   * **Adaptación:** Añadir escalamiento de fallos a través de tickets en sistema ITSM (e.g., ServiceNow) y reportes gráficos.

**Backup de configuraciones de dispositivos de red**

   * **Descripción:** Script en Python usando Netmiko/NAPALM para conectarse vía SSH a routers y switches, extraer configuración y almacenarla con fecha.

   * **Repositorio:** [https://github.com/ktbyers/netmiko/blob/develop/examples/config\_backup.py](https://github.com/ktbyers/netmiko/blob/develop/examples/config_backup.py)

   * **Adaptación:** Integrar con control de versiones (Git), enviar notificaciones en caso de cambios no autorizados y cifrar los backups.

---

## Adaptar un script para la solución de un problema considerando su codificación, aplicando las buenas prácticas de programación, utilizando las tecnologías de información y comunicación, empleando el pensamiento crítico y lógico-matemático; trabajando de forma autónoma o colaborativa y cumpliendo con las especificaciones de su jefe inmediato.

**Problema seleccionado:** Detección y notificación de múltiples intentos fallidos de inicio de sesión en archivos de log de sistemas Linux.

**Especificaciones del jefe inmediato:**

* Leer un archivo de log (`/var/log/auth.log`) y filtrar los eventos de "Failed password".
* Contar intentos fallidos por usuario e IP.
* Enviar un correo de alerta cuando un usuario supere 5 intentos fallidos en 10 minutos.
* Guardar un reporte CSV con timestamp, usuario, IP y número de intentos.
* Código estructurado con funciones, manejo de excepciones y configuración vía archivo `.ini`.

### Estructura del script

1. `load_config(path)`

   * Lee parámetros de conexión SMTP, umbrales y rutas desde un archivo INI.
2. `parse_logs(log_path, window_minutes)`

   * Extrae y agrupa los intentos fallidos en la ventana de tiempo.
3. `generate_report(data, output_csv)`

   * Escribe el CSV con los resultados.
4. `send_alert(alerts, smtp_config)`

   * Envía correo a lista de destinatarios si se superan umbrales.
5. `main()`

   * Orquestra la ejecución: carga configuración, analiza logs, genera reporte y envía alertas.

### Código (Python versión 3.8 +)

```python
import configparser
import csv
import smtplib
import time
from collections import defaultdict, deque
from datetime import datetime, timedelta
from email.message import EmailMessage


def load_config(path='config.ini'):
    config = configparser.ConfigParser()
    config.read(path)
    return config


def parse_logs(log_path, window_minutes):
    cutoff = datetime.now() - timedelta(minutes=window_minutes)
    attempts = defaultdict(lambda: defaultdict(int))  # attempts[user][ip] = count
    with open(log_path) as f:
        for line in f:
            if 'Failed password' in line:
                parts = line.split()
                # Ejemplo: 'Jun 13 12:00:01 host sshd[1234]: Failed password for invalid user root from 10.0.0.5 port 55874 ssh2'
                timestamp_str = ' '.join(parts[0:3])
                timestamp = datetime.strptime(timestamp_str, '%b %d %H:%M:%S')
                timestamp = timestamp.replace(year=datetime.now().year)
                if timestamp < cutoff:
                    continue
                user = parts[8]
                ip = parts[10]
                attempts[user][ip] += 1
    return attempts


def generate_report(data, output_csv):
    with open(output_csv, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(['Timestamp', 'User', 'IP', 'Attempts'])
        now = datetime.now().isoformat()
        for user, ips in data.items():
            for ip, count in ips.items():
                writer.writerow([now, user, ip, count])


def send_alert(attempts, smtp_config, threshold):
    alerts = []
    for user, ips in attempts.items():
        for ip, count in ips.items():
            if count > threshold:
                alerts.append((user, ip, count))

    if not alerts:
        return

    msg = EmailMessage()
    msg['Subject'] = f'Alerta: {len(alerts)} usuarios con intentos fallidos'
    msg['From'] = smtp_config['from']
    msg['To'] = smtp_config['to'].split(',')
    body = 'Se han detectado los siguientes intentos fallidos:\n'
    for user, ip, count in alerts:
        body += f'- Usuario: {user}, IP: {ip}, Intentos: {count}\n'
    msg.set_content(body)

    with smtplib.SMTP(smtp_config['host'], smtp_config.getint('port')) as server:
        if smtp_config.getboolean('starttls'):
            server.starttls()
        server.login(smtp_config['user'], smtp_config['password'])
        server.send_message(msg)


def main():
    config = load_config()
    log_path = config['Paths']['log_file']
    window = config['Settings'].getint('window_minutes')
    threshold = config['Settings'].getint('threshold')
    output_csv = config['Paths']['report_csv']

    attempts = parse_logs(log_path, window)
    generate_report(attempts, output_csv)
    send_alert(attempts, config['SMTP'], threshold)


if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        print(f'Error en ejecución: {e}')
        exit(1)
```

**Buenas prácticas consideradas:**

* Modularización en funciones claras.
* Configuración externa vía `config.ini`.
* Manejo de excepciones en el bloque principal.
* Uso de estructuras de datos eficientes (`defaultdict`).
* Comentarios y docstrings implícitos a través de nombres descriptivos.
* Generación de reportes y comunicación mediante correo.

---

Estos entregables cumplen con las actividades solicitadas en el Submódulo 2 del Módulo 1 del diplomado de ciberseguridad, demostrando tanto la identificación y análisis de scripts existentes como la implementación de un script Python adaptado a necesidades reales de una empresa.
